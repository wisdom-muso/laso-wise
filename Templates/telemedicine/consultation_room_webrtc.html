{% extends 'core/base.html' %}
{% load static %}
{% load i18n %}

{% block title %}{% translate "Video Consultation Room" %}{% endblock %}

{% block extra_css %}
<style>
    .consultation-room {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 0;
    }
    
    .video-container {
        position: relative;
        background: #000;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    
    .main-video {
        width: 100%;
        height: 400px;
        object-fit: cover;
        border-radius: 15px;
        background: #1a1a1a;
    }
    
    .self-video {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 200px;
        height: 150px;
        border-radius: 10px;
        border: 3px solid #fff;
        object-fit: cover;
        z-index: 10;
        background: #333;
    }
    
    .video-controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        z-index: 20;
    }
    
    .control-btn {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: none;
        color: white;
        font-size: 18px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .control-btn.video-btn {
        background: rgba(76, 175, 80, 0.9);
    }
    
    .control-btn.video-btn.muted {
        background: rgba(244, 67, 54, 0.9);
    }
    
    .control-btn.audio-btn {
        background: rgba(33, 150, 243, 0.9);
    }
    
    .control-btn.audio-btn.muted {
        background: rgba(244, 67, 54, 0.9);
    }
    
    .control-btn.screen-btn {
        background: rgba(156, 39, 176, 0.9);
    }
    
    .control-btn.screen-btn.active {
        background: rgba(255, 193, 7, 0.9);
    }
    
    .control-btn.end-btn {
        background: rgba(244, 67, 54, 0.9);
        width: 60px;
        height: 60px;
    }
    
    .control-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .chat-panel {
        background: white;
        border-radius: 15px;
        height: 500px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 5px 20px rgba(0,0,0,0.1);
    }
    
    .chat-header {
        padding: 15px 20px;
        border-bottom: 1px solid #eee;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 15px 15px 0 0;
    }
    
    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 15px;
        max-height: 350px;
    }
    
    .message {
        margin-bottom: 15px;
        padding: 10px 15px;
        border-radius: 18px;
        max-width: 80%;
        word-wrap: break-word;
        animation: fadeIn 0.3s ease;
    }
    
    .message.sent {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        margin-left: auto;
        text-align: right;
    }
    
    .message.received {
        background: #f1f3f4;
        color: #333;
        margin-right: auto;
    }
    
    .message-sender {
        font-weight: bold;
        font-size: 0.85rem;
        margin-bottom: 5px;
    }
    
    .message-time {
        font-size: 0.75rem;
        opacity: 0.7;
        margin-top: 5px;
    }
    
    .chat-input {
        padding: 15px;
        border-top: 1px solid #eee;
        border-radius: 0 0 15px 15px;
    }
    
    .input-group {
        display: flex;
        gap: 10px;
    }
    
    .message-input {
        flex: 1;
        border: 1px solid #ddd;
        border-radius: 25px;
        padding: 12px 20px;
        font-size: 14px;
        outline: none;
        transition: border-color 0.3s ease;
    }
    
    .message-input:focus {
        border-color: #667eea;
    }
    
    .send-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        border-radius: 50%;
        width: 45px;
        height: 45px;
        color: white;
        cursor: pointer;
        transition: transform 0.3s ease;
    }
    
    .send-btn:hover {
        transform: scale(1.1);
    }
    
    .consultation-header {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 20px;
        margin-bottom: 30px;
        border-radius: 15px;
        color: white;
    }
    
    .consultation-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .connection-status {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #4CAF50;
        animation: pulse 2s infinite;
    }
    
    .status-indicator.connecting {
        background: #FF9800;
    }
    
    .status-indicator.poor {
        background: #F44336;
    }
    
    .status-indicator.disconnected {
        background: #9E9E9E;
    }
    
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
        100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
    }
    
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    .waiting-room {
        text-align: center;
        color: white;
        padding: 50px;
    }
    
    .waiting-spinner {
        font-size: 3rem;
        animation: spin 2s linear infinite;
        margin-bottom: 20px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .consultation-ended {
        text-align: center;
        color: white;
        padding: 50px;
    }
    
    .participant-info {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 10px;
    }
    
    .participant-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
    }
    
    .duration-timer {
        font-family: 'Courier New', monospace;
        font-size: 1.2rem;
        font-weight: bold;
    }
    
    .video-placeholder {
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        text-align: center;
        font-size: 1.2rem;
        height: 100%;
        background: linear-gradient(45deg, #333, #555);
    }
    
    .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px 20px;
        border-radius: 10px;
        z-index: 1000;
        animation: slideIn 0.3s ease;
    }
    
    @keyframes slideIn {
        from { transform: translateX(100%); }
        to { transform: translateX(0); }
    }
    
    .recording-indicator {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(244, 67, 54, 0.9);
        color: white;
        padding: 8px 15px;
        border-radius: 20px;
        font-size: 0.9rem;
        z-index: 15;
        display: none;
    }
    
    .recording-indicator.active {
        display: block;
        animation: pulse 2s infinite;
    }
</style>
{% endblock %}

{% block content %}
<div class="consultation-room">
    <div class="container-fluid h-100">
        <!-- Consultation Header -->
        <div class="consultation-header">
            <div class="consultation-info">
                <div>
                    <h4 class="mb-2">
                        {% if is_doctor %}
                            {% translate "Consultation with Patient" %}: {{ consultation.appointment.patient.get_full_name }}
                        {% else %}
                            {% translate "Doctor Consultation" %}: Dr. {{ consultation.appointment.doctor.get_full_name }}
                        {% endif %}
                    </h4>
                    <div class="participant-info">
                        <div class="participant-avatar">
                            {% if is_doctor %}
                                {{ consultation.appointment.patient.first_name|first }}
                            {% else %}
                                {{ consultation.appointment.doctor.first_name|first }}
                            {% endif %}
                        </div>
                        <div>
                            <div class="duration-timer" id="duration-timer">00:00:00</div>
                            <small>{% translate "Consultation Duration" %}</small>
                        </div>
                    </div>
                </div>
                <div class="connection-status">
                    <div class="status-indicator" id="connection-indicator"></div>
                    <span id="connection-status">{% translate "Connecting..." %}</span>
                </div>
            </div>
        </div>

        <div class="row h-75">
            <!-- Video Section -->
            <div class="col-lg-8 mb-4">
                <div class="video-container">
                    <!-- Recording Indicator -->
                    <div class="recording-indicator" id="recording-indicator">
                        <i class="fas fa-circle me-2"></i>
                        {% translate "Recording" %}
                    </div>
                    
                    <!-- Main Video Stream -->
                    <video id="remoteVideo" class="main-video" autoplay playsinline></video>
                    
                    <!-- Remote Video Placeholder -->
                    <div id="remoteVideoPlaceholder" class="video-placeholder main-video">
                        <div>
                            <i class="fas fa-user fa-5x mb-3"></i><br>
                            {% translate "Waiting for other participant..." %}
                        </div>
                    </div>
                    
                    <!-- Self Video -->
                    <video id="localVideo" class="self-video" autoplay muted playsinline></video>
                    
                    <!-- Video Controls -->
                    <div class="video-controls">
                        <button class="control-btn video-btn" id="videoToggle" title="{% translate 'Toggle Camera' %}">
                            <i class="fas fa-video"></i>
                        </button>
                        <button class="control-btn audio-btn" id="audioToggle" title="{% translate 'Toggle Microphone' %}">
                            <i class="fas fa-microphone"></i>
                        </button>
                        <button class="control-btn screen-btn" id="screenShare" title="{% translate 'Share Screen' %}">
                            <i class="fas fa-desktop"></i>
                        </button>
                        {% if is_doctor %}
                        <button class="control-btn" style="background: rgba(76, 175, 80, 0.9);" id="recordToggle" title="{% translate 'Toggle Recording' %}">
                            <i class="fas fa-record-vinyl"></i>
                        </button>
                        <button class="control-btn end-btn" id="endConsultation" title="{% translate 'End Consultation' %}">
                            <i class="fas fa-phone-slash"></i>
                        </button>
                        {% endif %}
                    </div>
                </div>
            </div>

            <!-- Chat Panel -->
            <div class="col-lg-4">
                <div class="chat-panel">
                    <div class="chat-header">
                        <h6 class="mb-0">
                            <i class="fas fa-comments me-2"></i>
                            {% translate "Chat" %}
                        </h6>
                    </div>
                    
                    <div class="chat-messages" id="chatMessages">
                        <!-- Chat messages will be loaded here -->
                    </div>
                    
                    <div class="chat-input">
                        <div class="input-group">
                            <input type="text" class="message-input" id="messageInput" 
                                   placeholder="{% translate 'Write a message...' %}"
                                   maxlength="500">
                            <button class="send-btn" id="sendMessage">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Consultation Notes Modal (For Doctors) -->
        {% if is_doctor %}
        <div class="modal fade" id="endConsultationModal" tabindex="-1">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">{% translate "End Consultation" %}</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <form id="endConsultationForm">
                            <div class="mb-3">
                                <label for="consultationNotes" class="form-label">{% translate "Consultation Notes" %}</label>
                                <textarea class="form-control" id="consultationNotes" rows="4"
                                          placeholder="{% translate 'Assessments, recommendations, etc. made during the consultation.' %}"></textarea>
                            </div>
                            <div class="mb-3">
                                <label for="patientFeedback" class="form-label">{% translate "Patient Feedback" %}</label>
                                <textarea class="form-control" id="patientFeedback" rows="3"
                                          placeholder="{% translate 'Feedback provided by the patient' %}"></textarea>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{% translate "Cancel" %}</button>
                        <button type="button" class="btn btn-danger" id="confirmEndConsultation">
                            {% translate "End Consultation" %}
                        </button>
                    </div>
                </div>
            </div>
        </div>
        {% endif %}
    </div>
</div>

<!-- Notification Container -->
<div id="notifications"></div>
{% endblock %}

{% block extra_js %}
<script>
// Global variables
const consultationId = '{{ consultation.id }}';
const userRole = '{{ user_role }}';
const currentUserId = {{ user.id }};
const isDoctor = {{ is_doctor|yesno:"true,false" }};

class TeleMedicineConsultation {
    constructor(consultationId, userRole) {
        this.consultationId = consultationId;
        this.userRole = userRole;
        this.localStream = null;
        this.remoteStream = null;
        this.peerConnection = null;
        this.websocket = null;
        this.isVideoEnabled = true;
        this.isAudioEnabled = true;
        this.isScreenSharing = false;
        this.isRecording = false;
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.startTime = new Date();
        
        // WebRTC Configuration with STUN servers
        this.rtcConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10
        };
        
        this.init();
    }
    
    async init() {
        try {
            await this.setupWebSocket();
            await this.setupLocalStream();
            this.setupEventListeners();
            this.startDurationTimer();
            this.showNotification('Connected to consultation room', 'success');
        } catch (error) {
            console.error('Initialization error:', error);
            this.showNotification('Failed to initialize consultation', 'error');
        }
    }
    
    setupWebSocket() {
        return new Promise((resolve, reject) => {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/consultation/${this.consultationId}/`;
            
            this.websocket = new WebSocket(wsUrl);
            
            this.websocket.onopen = () => {
                console.log('WebSocket connected');
                this.updateConnectionStatus('connected');
                resolve();
            };
            
            this.websocket.onmessage = async (event) => {
                try {
                    const data = JSON.parse(event.data);
                    await this.handleWebSocketMessage(data);
                } catch (error) {
                    console.error('Error handling WebSocket message:', error);
                }
            };
            
            this.websocket.onclose = (event) => {
                console.log('WebSocket disconnected:', event.code);
                this.updateConnectionStatus('disconnected');
                // Implement reconnection logic
                setTimeout(() => this.reconnectWebSocket(), 3000);
            };
            
            this.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.updateConnectionStatus('poor');
                reject(error);
            };
        });
    }
    
    async reconnectWebSocket() {
        if (this.websocket.readyState === WebSocket.CLOSED) {
            try {
                await this.setupWebSocket();
                this.showNotification('Reconnected to consultation', 'success');
            } catch (error) {
                console.error('Reconnection failed:', error);
                setTimeout(() => this.reconnectWebSocket(), 5000);
            }
        }
    }
    
    async handleWebSocketMessage(data) {
        switch (data.type) {
            case 'user_joined':
                await this.handleUserJoined(data);
                break;
            case 'user_left':
                this.handleUserLeft(data);
                break;
            case 'webrtc_offer':
                await this.handleWebRTCOffer(data);
                break;
            case 'webrtc_answer':
                await this.handleWebRTCAnswer(data);
                break;
            case 'ice_candidate':
                await this.handleICECandidate(data);
                break;
            case 'chat_message':
                this.displayChatMessage(data);
                break;
            case 'screen_share_start':
                this.handleScreenShareStart(data);
                break;
            case 'screen_share_stop':
                this.handleScreenShareStop(data);
                break;
            case 'media_state_change':
                this.handleMediaStateChange(data);
                break;
        }
    }
    
    async setupLocalStream() {
        try {
            const constraints = {
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }
                },
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            };
            
            this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
            document.getElementById('localVideo').srcObject = this.localStream;
            
            // Enable controls
            this.enableControls();
            
        } catch (error) {
            console.error('Error accessing media devices:', error);
            this.showError('Camera and microphone access is required for video consultation');
            this.disableControls();
        }
    }
    
    async createPeerConnection() {
        this.peerConnection = new RTCPeerConnection(this.rtcConfiguration);
        
        // Add local stream tracks
        if (this.localStream) {
            this.localStream.getTracks().forEach(track => {
                this.peerConnection.addTrack(track, this.localStream);
            });
        }
        
        // Handle remote stream
        this.peerConnection.ontrack = (event) => {
            console.log('Received remote stream');
            this.remoteStream = event.streams[0];
            const remoteVideo = document.getElementById('remoteVideo');
            const placeholder = document.getElementById('remoteVideoPlaceholder');
            
            remoteVideo.srcObject = this.remoteStream;
            remoteVideo.style.display = 'block';
            placeholder.style.display = 'none';
            
            this.updateConnectionStatus('connected');
        };
        
        // Handle ICE candidates
        this.peerConnection.onicecandidate = (event) => {
            if (event.candidate && this.websocket.readyState === WebSocket.OPEN) {
                this.websocket.send(JSON.stringify({
                    type: 'ice_candidate',
                    candidate: event.candidate
                }));
            }
        };
        
        // Connection state monitoring
        this.peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', this.peerConnection.connectionState);
            this.updateConnectionStatus(this.peerConnection.connectionState);
            
            if (this.peerConnection.connectionState === 'failed') {
                this.handleConnectionFailure();
            }
        };
        
        // ICE connection state
        this.peerConnection.oniceconnectionstatechange = () => {
            console.log('ICE connection state:', this.peerConnection.iceConnectionState);
        };
    }
    
    async handleUserJoined(data) {
        this.showNotification(`${data.user_name} joined the consultation`, 'info');
        
        // If other participant joined and we're the doctor, initiate call
        if (data.user_role !== this.userRole && this.userRole === 'doctor') {
            setTimeout(() => this.initiateCall(), 1000);
        }
    }
    
    handleUserLeft(data) {
        this.showNotification(`${data.user_name} left the consultation`, 'warning');
        
        // Hide remote video
        const remoteVideo = document.getElementById('remoteVideo');
        const placeholder = document.getElementById('remoteVideoPlaceholder');
        
        remoteVideo.style.display = 'none';
        placeholder.style.display = 'flex';
        
        // Close peer connection
        if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
    }
    
    async initiateCall() {
        try {
            await this.createPeerConnection();
            
            const offer = await this.peerConnection.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });
            
            await this.peerConnection.setLocalDescription(offer);
            
            this.websocket.send(JSON.stringify({
                type: 'webrtc_offer',
                offer: offer
            }));
            
            console.log('WebRTC offer sent');
            
        } catch (error) {
            console.error('Error initiating call:', error);
            this.showNotification('Failed to start video call', 'error');
        }
    }
    
    async handleWebRTCOffer(data) {
        try {
            await this.createPeerConnection();
            
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
            
            const answer = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(answer);
            
            this.websocket.send(JSON.stringify({
                type: 'webrtc_answer',
                answer: answer
            }));
            
            console.log('WebRTC answer sent');
            
        } catch (error) {
            console.error('Error handling WebRTC offer:', error);
            this.showNotification('Failed to establish video connection', 'error');
        }
    }
    
    async handleWebRTCAnswer(data) {
        try {
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
            console.log('WebRTC answer received');
        } catch (error) {
            console.error('Error handling WebRTC answer:', error);
        }
    }
    
    async handleICECandidate(data) {
        try {
            await this.peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        } catch (error) {
            console.error('Error adding ICE candidate:', error);
        }
    }
    
    async handleConnectionFailure() {
        this.showNotification('Connection failed. Attempting to reconnect...', 'error');
        
        // Attempt to restart the connection
        setTimeout(async () => {
            if (this.userRole === 'doctor') {
                await this.initiateCall();
            }
        }, 2000);
    }
    
    setupEventListeners() {
        // Video toggle
        document.getElementById('videoToggle').addEventListener('click', () => {
            this.toggleVideo();
        });
        
        // Audio toggle
        document.getElementById('audioToggle').addEventListener('click', () => {
            this.toggleAudio();
        });
        
        // Screen share
        document.getElementById('screenShare').addEventListener('click', () => {
            this.toggleScreenShare();
        });
        
        // Recording (doctors only)
        if (isDoctor) {
            document.getElementById('recordToggle').addEventListener('click', () => {
                this.toggleRecording();
            });
            
            // End consultation
            document.getElementById('endConsultation').addEventListener('click', () => {
                this.showEndConsultationModal();
            });
            
            document.getElementById('confirmEndConsultation').addEventListener('click', () => {
                this.endConsultation();
            });
        }
        
        // Chat functionality
        document.getElementById('sendMessage').addEventListener('click', () => {
            this.sendChatMessage();
        });
        
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendChatMessage();
            }
        });
        
        // Handle page unload
        window.addEventListener('beforeunload', () => {
            this.cleanup();
        });
    }
    
    toggleVideo() {
        this.isVideoEnabled = !this.isVideoEnabled;
        const videoTrack = this.localStream?.getVideoTracks()[0];
        
        if (videoTrack) {
            videoTrack.enabled = this.isVideoEnabled;
        }
        
        const button = document.getElementById('videoToggle');
        button.classList.toggle('muted', !this.isVideoEnabled);
        button.innerHTML = this.isVideoEnabled ? 
            '<i class="fas fa-video"></i>' : 
            '<i class="fas fa-video-slash"></i>';
        
        // Notify other participant
        this.sendMediaState();
    }
    
    toggleAudio() {
        this.isAudioEnabled = !this.isAudioEnabled;
        const audioTrack = this.localStream?.getAudioTracks()[0];
        
        if (audioTrack) {
            audioTrack.enabled = this.isAudioEnabled;
        }
        
        const button = document.getElementById('audioToggle');
        button.classList.toggle('muted', !this.isAudioEnabled);
        button.innerHTML = this.isAudioEnabled ? 
            '<i class="fas fa-microphone"></i>' : 
            '<i class="fas fa-microphone-slash"></i>';
        
        // Notify other participant
        this.sendMediaState();
    }
    
    async toggleScreenShare() {
        if (!this.isScreenSharing) {
            await this.startScreenShare();
        } else {
            await this.stopScreenShare();
        }
    }
    
    async startScreenShare() {
        try {
            const screenStream = await navigator.mediaDevices.getDisplayMedia({
                video: true,
                audio: true
            });
            
            // Replace video track in peer connection
            const videoTrack = screenStream.getVideoTracks()[0];
            const sender = this.peerConnection?.getSenders().find(s => 
                s.track && s.track.kind === 'video'
            );
            
            if (sender) {
                await sender.replaceTrack(videoTrack);
            }
            
            // Update local video
            document.getElementById('localVideo').srcObject = screenStream;
            
            // Handle screen share end
            videoTrack.onended = () => {
                this.stopScreenShare();
            };
            
            this.isScreenSharing = true;
            const button = document.getElementById('screenShare');
            button.classList.add('active');
            button.innerHTML = '<i class="fas fa-stop"></i>';
            
            // Notify other participant
            this.websocket.send(JSON.stringify({
                type: 'screen_share_start'
            }));
            
            this.showNotification('Screen sharing started', 'success');
            
        } catch (error) {
            console.error('Error starting screen share:', error);
            this.showNotification('Failed to start screen sharing', 'error');
        }
    }
    
    async stopScreenShare() {
        try {
            // Get camera stream back
            const cameraStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true
            });
            
            const videoTrack = cameraStream.getVideoTracks()[0];
            const sender = this.peerConnection?.getSenders().find(s => 
                s.track && s.track.kind === 'video'
            );
            
            if (sender) {
                await sender.replaceTrack(videoTrack);
            }
            
            // Update local video
            document.getElementById('localVideo').srcObject = cameraStream;
            this.localStream = cameraStream;
            
            this.isScreenSharing = false;
            const button = document.getElementById('screenShare');
            button.classList.remove('active');
            button.innerHTML = '<i class="fas fa-desktop"></i>';
            
            // Notify other participant
            this.websocket.send(JSON.stringify({
                type: 'screen_share_stop'
            }));
            
            this.showNotification('Screen sharing stopped', 'info');
            
        } catch (error) {
            console.error('Error stopping screen share:', error);
        }
    }
    
    toggleRecording() {
        if (!this.isRecording) {
            this.startRecording();
        } else {
            this.stopRecording();
        }
    }
    
    startRecording() {
        try {
            // Combine local and remote streams for recording
            const combinedStream = new MediaStream();
            
            if (this.localStream) {
                this.localStream.getTracks().forEach(track => {
                    combinedStream.addTrack(track);
                });
            }
            
            if (this.remoteStream) {
                this.remoteStream.getTracks().forEach(track => {
                    combinedStream.addTrack(track);
                });
            }
            
            this.mediaRecorder = new MediaRecorder(combinedStream, {
                mimeType: 'video/webm;codecs=vp9'
            });
            
            this.recordedChunks = [];
            
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.recordedChunks.push(event.data);
                }
            };
            
            this.mediaRecorder.onstop = () => {
                this.saveRecording();
            };
            
            this.mediaRecorder.start(1000); // Record in 1-second chunks
            
            this.isRecording = true;
            document.getElementById('recording-indicator').classList.add('active');
            
            const button = document.getElementById('recordToggle');
            button.style.background = 'rgba(244, 67, 54, 0.9)';
            button.innerHTML = '<i class="fas fa-stop"></i>';
            
            this.showNotification('Recording started', 'success');
            
        } catch (error) {
            console.error('Error starting recording:', error);
            this.showNotification('Failed to start recording', 'error');
        }
    }
    
    stopRecording() {
        if (this.mediaRecorder && this.isRecording) {
            this.mediaRecorder.stop();
            
            this.isRecording = false;
            document.getElementById('recording-indicator').classList.remove('active');
            
            const button = document.getElementById('recordToggle');
            button.style.background = 'rgba(76, 175, 80, 0.9)';
            button.innerHTML = '<i class="fas fa-record-vinyl"></i>';
            
            this.showNotification('Recording stopped', 'info');
        }
    }
    
    saveRecording() {
        const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        
        // Create download link
        const a = document.createElement('a');
        a.href = url;
        a.download = `consultation-${this.consultationId}-${new Date().toISOString()}.webm`;
        a.click();
        
        URL.revokeObjectURL(url);
        
        // TODO: Upload to server
        this.uploadRecording(blob);
    }
    
    async uploadRecording(blob) {
        const formData = new FormData();
        formData.append('recording', blob, `consultation-${this.consultationId}.webm`);
        formData.append('consultation_id', this.consultationId);
        
        try {
            const response = await fetch('/telemedicine/upload-recording/', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                }
            });
            
            if (response.ok) {
                this.showNotification('Recording saved successfully', 'success');
            } else {
                throw new Error('Upload failed');
            }
        } catch (error) {
            console.error('Error uploading recording:', error);
            this.showNotification('Failed to save recording', 'error');
        }
    }
    
    sendMediaState() {
        if (this.websocket.readyState === WebSocket.OPEN) {
            this.websocket.send(JSON.stringify({
                type: 'media_state',
                video_enabled: this.isVideoEnabled,
                audio_enabled: this.isAudioEnabled
            }));
        }
    }
    
    handleMediaStateChange(data) {
        // Visual indication of other participant's media state
        // This could be implemented to show mute indicators
        console.log('Other participant media state:', data);
    }
    
    handleScreenShareStart(data) {
        this.showNotification(`${data.sender_name} started screen sharing`, 'info');
    }
    
    handleScreenShareStop(data) {
        this.showNotification('Screen sharing stopped', 'info');
    }
    
    sendChatMessage() {
        const input = document.getElementById('messageInput');
        const message = input.value.trim();
        
        if (message && this.websocket.readyState === WebSocket.OPEN) {
            this.websocket.send(JSON.stringify({
                type: 'chat_message',
                message: message
            }));
            
            input.value = '';
        }
    }
    
    displayChatMessage(data) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${data.is_own ? 'sent' : 'received'}`;
        
        const time = new Date(data.timestamp).toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit'
        });
        
        messageDiv.innerHTML = `
            <div class="message-sender">${data.sender_name}</div>
            <div>${data.message}</div>
            <div class="message-time">${time}</div>
        `;
        
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    updateConnectionStatus(state) {
        const indicator = document.getElementById('connection-indicator');
        const status = document.getElementById('connection-status');
        
        indicator.className = 'status-indicator';
        
        switch (state) {
            case 'connected':
                status.textContent = 'Connection Good';
                break;
            case 'connecting':
                indicator.classList.add('connecting');
                status.textContent = 'Connecting...';
                break;
            case 'disconnected':
                indicator.classList.add('disconnected');
                status.textContent = 'Disconnected';
                break;
            case 'failed':
            case 'poor':
                indicator.classList.add('poor');
                status.textContent = 'Connection Issues';
                break;
        }
    }
    
    startDurationTimer() {
        setInterval(() => {
            const now = new Date();
            const duration = now - this.startTime;
            const hours = Math.floor(duration / 3600000);
            const minutes = Math.floor((duration % 3600000) / 60000);
            const seconds = Math.floor((duration % 60000) / 1000);
            
            document.getElementById('duration-timer').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }, 1000);
    }
    
    showEndConsultationModal() {
        const modal = new bootstrap.Modal(document.getElementById('endConsultationModal'));
        modal.show();
    }
    
    async endConsultation() {
        const notes = document.getElementById('consultationNotes').value;
        const feedback = document.getElementById('patientFeedback').value;
        
        try {
            const response = await fetch(`/telemedicine/end-consultation/${this.consultationId}/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: JSON.stringify({
                    notes: notes,
                    patient_feedback: feedback
                })
            });
            
            if (response.ok) {
                this.showNotification('Consultation ended successfully', 'success');
                setTimeout(() => {
                    window.location.href = '/telemedicine/consultations/';
                }, 2000);
            } else {
                throw new Error('Failed to end consultation');
            }
        } catch (error) {
            console.error('Error ending consultation:', error);
            this.showNotification('Failed to end consultation', 'error');
        }
    }
    
    enableControls() {
        document.querySelectorAll('.control-btn').forEach(btn => {
            btn.disabled = false;
        });
    }
    
    disableControls() {
        document.querySelectorAll('.control-btn').forEach(btn => {
            btn.disabled = true;
        });
    }
    
    showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.innerHTML = `
            <i class="fas fa-${type === 'success' ? 'check' : type === 'error' ? 'exclamation-triangle' : 'info'} me-2"></i>
            ${message}
        `;
        
        document.getElementById('notifications').appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 5000);
    }
    
    showError(message) {
        this.showNotification(message, 'error');
    }
    
    cleanup() {
        if (this.mediaRecorder && this.isRecording) {
            this.stopRecording();
        }
        
        if (this.localStream) {
            this.localStream.getTracks().forEach(track => track.stop());
        }
        
        if (this.peerConnection) {
            this.peerConnection.close();
        }
        
        if (this.websocket) {
            this.websocket.close();
        }
    }
}

// Initialize consultation when page loads
document.addEventListener('DOMContentLoaded', () => {
    const consultation = new TeleMedicineConsultation(consultationId, userRole);
    
    // Make it globally accessible for debugging
    window.consultation = consultation;
});
</script>
{% endblock %}